C dilinde:
* Tek boyutlu diziler bellekte ardışık olarak tutulur.
* İki boyutlu dizi dediğimiz yapı aslında iç içe diziler değildir, tek boyutlu düz bir bloktur.

```c
int mat[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```
Bu aslında şöyle saklanmaktadır:
```c
mat = [1][2][3][4][5][6]  // düz bir blok şeklinde tutulur
```
Bellek adresi açısından duruma bakacak olursak:
```c
&mat[0][0] → ilk eleman
&mat[0][1] → sonraki eleman
&mat[1][0] → dizi boyutu kadar ileri atlama (Başlangıç adresinden 3 int size kadar ileri)
```
2 Boyutlu bir matrisi bir fonksiyona parametre olarak nasıl geçilmelidir?
```c
void printMatrix(int m[][3], int rows); // ✔️
```

```c
void printMatrix(int m[][], int rows); // ❌
```

C derleyicisi ikinci boyutun kaç olduğunu bilmez.
Çünkü çok boyutlu diziye erişirken adres hesaplaması yapması gerekmektedir. C dili 2.boyutu şöyle hesaplamaktadır:
```c
m[i][j] → *(m + i * cols + j)
```
Yani ikinci boyutun (sütun sayısının) bilinmesi matematiksel olarak zorunludur.
Örnek 1:
```c
#include <stdio.h>

void printMatrix(int m[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", m[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int mat[2][3] = {{1,2,3}, {4,5,6}};
    printMatrix(mat, 2);
    return 0;
}
```
Burada m[][3] ifadesi sayesinde derleyici m[i][j] için i * 3 + j adresini doğru hesaplayabilir.
Örnek 2:
```c
void printMatrix(int m[][], int rows); // ❌ HATALI

int main() {
    int mat[2][3] = {{1,2,3}, {4,5,6}};
    printMatrix(mat, 2);
    return 0;
}
```
Derleyici m[i][j] için adres hesaplayamaz çünkü j’yi kaçla çarpacağını bilmiyor.
Örnek 3: Sabit sütun sayısını #define ile belirtmek
```c
#include <stdio.h>
#define COLS 3

void printMatrix(int m[][COLS], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < COLS; j++) {
            printf("%d ", m[i][j]);
        }
        printf("\n");
    }
}
```
SORU : Neden Tek Boyutta İkinci Bilgi Gerekmez?
```c
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}
```
Bu kod geçerlidir çünkü arr[i] → *(arr + i) ve i * 1 → zaten sabit (int tipi sabit genişlikte).


















